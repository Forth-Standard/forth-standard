\chapter{The optional Facility word set} % 10
\wordlist{facility}

\begin{intro}
\section{The optional Facility word set}
\end{intro}

\section{Introduction} % 10.1

\section{Additional terms and notation} % 10.2
None.

\section{Additional usage requirements} % 10.3

\subsection{Data types} % 10.3.1

Append table \ref{facility:types} to table \ref{table:datatypes}.

\begin{table}[h]
  \begin{center}
	\caption{Data types}
	\label{facility:types}
	\begin{tabular}{llr}
	\hline\hline
	\emph{Symbol} & \emph{Data type} & \emph{Size on stack} \\
	\hline
	\emph{struct-sys}
	& data structures
	& implementation dependent \\
	\hline\hline
	\end{tabular}
  \end{center}
\end{table}

\subsubsection{Structure type} % 10.3.1.1

The implementation-dependent data generated upon beginning to compile
a \word{BEGIN-STRUCTURE} {\ldots} \word{END-STRUCTURE} structure and
consumed at its close is represented by the symbol \param{struct-sys}
throughout this Standard.

\subsubsection{Character types} % 10.3.1.2
Programs that use more than seven bits of a character by
\word{EKEY} have an environmental dependency.

See: \xref[3.1.2 Character types]{usage:char}.

\subsection{Environmental queries} % 10.3.2
Append table \ref{facility:env} to table \ref{table:env}.

See: \xref[3.2.6 Environmental queries]{usage:env}.

\begin{table}[h]
  \begin{center}
	\caption{Environmental Query Strings}
	\label{facility:env}
	\begin{tabular}{p{9em}rcp{0.42\textwidth}}
		\hline\hline
		\multicolumn{2}{l}{String \hfill Value data type} & Constant? & Meaning \\
		\hline
		\texttt{FACILITY}		& \emph{flag}	& no	&
			facility word set present \\
		\texttt{FACILITY-EXT}	& \emph{flag}	& no	&
			facility extensions word set present \\
		\hline\hline
	\end{tabular}
  \end{center}
\end{table}

\section{Additional documentation requirements} % 10.4

\subsection{System documentation} % 10.4.1

\subsubsection{Implementation-defined options} % 10.4.1.1

\begin{itemize}
\item encoding of keyboard events \wref{facility:EKEY}{EKEY});
\item duration of a system clock tick;
\item repeatability to be expected from execution of
	\wref{facility:MS}{MS}.
\end{itemize}

\subsubsection{Ambiguous conditions} % 10.4.1.2

\begin{itemize}
\item \wref{facility:AT-XY}{AT-XY} operation can't be performed on
	user output device.

\item A \param{name} defined by
	\wref{facility:BEGIN-STRUCTURE}{BEGIN-STRUCTURE}
	is executed before the corresponding
	\wref{facility:END-STRUCTURE}{END-STRUCTURE}
	has been executed.
\end{itemize}

\subsubsection{Other system documentation} % 10.4.1.3

\begin{itemize}
\item no additional requirements.
\end{itemize}

\subsection{Program documentation} % 10.4.2

\subsubsection{Environmental dependencies} % 10.4.2.1

\begin{itemize}
\item using more than seven bits of a character in
	\wref{facility:EKEY}{EKEY}.
\end{itemize}

\subsubsection{Other program documentation} % 10.4.2.2

\begin{itemize}
\item no additional requirements.
\end{itemize}

\section{Compliance and labeling} % 10.5

\subsection{ANS Forth systems} % 10.5.1

The phrase ``Providing the Facility word set'' shall be appended to
the label of any Standard System that provides all of the Facility
word set.

The phrase ``Providing \emph{name(s)} from the Facility Extensions
word set'' shall be appended to the label of any Standard System
that provides portions of the Facility Extensions word set.

The phrase ``Providing the Facility Extensions word set'' shall be
appended to the label of any Standard System that provides all of
the Facility and Facility Extensions word sets.

\subsection{ANS Forth programs} % 10.5.2

The phrase ``Requiring the Facility word set'' shall be appended to
the label of Standard Programs that require the system to provide
the Facility word set.

The phrase ``Requiring \emph{name(s)} from the Facility Extensions
word set'' shall be appended to the label of Standard Programs that
require the system to provide portions of the Facility Extensions
word set.

The phrase ``Requiring the Facility Extensions word set'' shall be
appended to the label of Standard Programs that require the system
to provide all of the Facility and Facility Extensions word sets.

\section{Glossary} % 10.6

\begin{intro}
\subsection{Glossary} % A.10.6
\end{intro}

\subsection{Facility words} % 10.6.1

\begin{worddef}{0742}{AT-XY}[at-x-y]
\item \stack{u_1 u_2}{}

	Perform implementation-dependent steps so that the next
	character displayed will appear in column \param{u_1}, row
	\param{u_2} of the user output device, the upper left corner
	of which is column zero, row zero. An ambiguous condition exists
	if the operation cannot be performed on the user output device
	with the specified parameters.

	\begin{defer}
	\rationale % A.10.6.1.0742 AT-XY
		Most implementors supply a method of positioning a cursor on
		a CRT screen, but there is great variance in names and stack
		arguments. This version is supported by at least one major
		vendor.
	\end{defer}
\end{worddef}


\begin{worddef}[KEYq]{1755}{KEY?}[key-question]
\item \stack{}{flag}

	If a character is available, return \emph{true}. Otherwise,
	return \emph{false}. If non-character keyboard events are
	available before the first valid character, they are discarded
	and are subsequently unavailable. The character shall be
	returned by the next execution of \word[core]{KEY}.

	After \word{KEYq} returns with a value of \emph{true},
	subsequent executions of \word{KEYq} prior to the execution
	of \word[core]{KEY} or \word{EKEY} also return \emph{true},
	without discarding keyboard events.

	\begin{defer}
	\rationale % A.10.6.1.1755 KEY?
		The Technical Committee has gone around several times on the
		stack effects. Whatever is decided will violate somebody's
		practice and penalize some machine. This way doesn't interfere
		with type-ahead on some systems, while requiring the
		implementation of a single-character buffer on machines where
		polling the keyboard inevitably results in the destruction of
		the character.

		Use of \word[core]{KEY} or \word{KEYq} indicates that the
		application does not wish to bother with non-character events,
		so they are discarded, in anticipation of eventually receiving
		a valid character. Applications wishing to handle non-character
		events must use \word{EKEY} and \word{EKEYq}. It is possible
		to mix uses of \word{KEYq}/\word[core]{KEY} and
		\word{EKEYq}/\word{EKEY} within a single application, but
		the application must use \word{KEYq} and \word[core]{KEY} only
		when it wishes to discard non-character events until a valid
		character is received.
	\end{defer}
\end{worddef}


\begin{worddef}{2005}{PAGE}
\item \stack{}{}

	Move to another page for output. Actual function depends on the
	output device. On a terminal, \word{PAGE} clears the screen and
	resets the cursor position to the upper left corner. On a
	printer, \word{PAGE} performs a form feed.
\end{worddef}


\subsection{Facility extension words} % 10.6.2
\extended

% -------------------------------------

\begin{worddef}{}{+FIELD}[plus-field][X:structures]
\item \stack{n_1 n_2 "<spaces>name"}{n_3}

	Skip leading space delimiters.  Parse \param{name} delimited
	by a space.  Create a definition for \param{name} with the
	execution semantics defined below.  Return \param{n_3} =
	\param{n_1} + \param{n_2} where \param{n_1} is the offset
	in the data structure before \word{+FIELD} executes, and
	\param{n_2} is the size of the data to be added to the data
	structure. \param{n_1} and \param{n_2} are in address units.

\execute[name]
	\stack{addr_1}{addr_2}

	Add \param{n_1} to \param{addr_1} giving \param{addr_2}.

\see \wref{facility:BEGIN-STRUCTURE}{BEGIN-STRUCTURE},
	\wref{facility:END-STRUCTURE}{END-STRUCTURE},
	\wref{facility:CFIELD:}{CFIELD:},
	\wref{facility:FIELD:}{FIELD:},
	\wref{floating:FFIELD:}{FFIELD:},
	\wref{floating:SFFIELD:}{SFFIELD:} and
	\wref{floating:DFFIELD:}{DFFIELD:}

	\begin{defer}
	\rationale
		\word{+FIELD} is not required to align items.  This is
		deliberate and allows the construction of unaligned data
		structures for communication with external elements such
		as a hardware register map or protocol packet.
		Field alignment has been left to the appropriate
		\emph{x}\texttt{FIELD:} definition.

	\implementation
		\defertext{Create a new field within a structure definition
			of size \param{n} bytes.}

		\word{:} +FIELD\tab\word{bs} n <"name"> -{}- ; Exec: addr -{}- 'addr \\
		\tab \word{CREATE} \word{OVER} \word{,} \word{+} \\
		\tab \word{DOES} \word{@} \word{+} \\
		\word{;}
	\end{defer}
\end{worddef}


\begin{worddef}{}{BEGIN-STRUCTURE}[][X:structures]
\item \stack{"<spaces>name"}{struct-sys 0}

	Skip leading space delimiters. Parse \param{name} delimited
	by a space. Create a definition for \param{name} with the
	execution semantics defined below.  Return a \param{struct-sys}
	(zero or more implementation dependent items) that will be
	used by \word{END-STRUCTURE} and an initial offset of 0.

\execute[name]
	\stack{}{+n}

	\param{+n} is the size in memory expressed in address units of
	the data structure.  An ambiguous condition exists if
	\param{name} is executed prior to the associated
	\word{END-STRUCTURE} being executed.

\see \wref{facility:+FIELD}{+FIELD} and
	\wref{facility:END-STRUCTURE}{END-STRUCTURE}.

	\begin{defer}
	\rationale
		There are two schools of \replace{ed08}{though}{thought} regarding named data
		structures: name first and name last.  The name last
		school can define a named data structure as follows:

		\begin{quote}\ttfamily
		0 \tab[11.5] \word{bs} initial total byte count \\
		\tab 1 \word{CELLS} \word{+FIELD} p.x	\tab \word{bs} A single cell filed named p.x \\
		\tab 1 \word{CELLS} \word{+FIELD} p.y   \tab \word{bs} A single cell field named p.y \\
		\word{CONSTANT} point \tab[3.8] \word{bs} save structure size
		\end{quote}

		While the name first school would define the same data
		structure as:

		\begin{quote}\ttfamily
		\word{BEGIN-STRUCTURE} point \tab[-.3] \word{bs} create the named structure \\
		\tab 1 \word{CELLS} \word{+FIELD} p.x	\tab \word{bs} A single cell filed named p.x \\
		\tab 1 \word{CELLS} \word{+FIELD} p.y   \tab \word{bs} A single cell field named p.y \\
		\word{END-STRUCTURE}
		\end{quote}

		Although many systems provide a name first structure there
		is no common practice to the words used.  The words
		\word{BEGIN-STRUCTURE} and \word{END-STRUCTURE} have been
		defied as a means of providing a portable notation that does
		not conflict with existing systems.

		The field defining words (\emph{x}\texttt{FIELD:} and
		\word{+FIELD}) are defined so they can be used by both
		schools.  Compatibility between the two schools comes from
		defining a new stack item \param{struct-sys}, which is
		implementation dependent and can be 0 or more cells.
		The name first school would provide an address (\param{addr})
		as the \param{struct-sys} parameter, while the name last
		school would defined \param{struct-sys} as being empty.

		Executing the name of the data structure, returns the size of
		the data structure.  This allows the data stricture to be used
		within another data structure:

		\begin{quote}\ttfamily
		\word{BEGIN-STRUCTURE} point \tab[-0.1] \word{bs} -{}- a-addr 0 ; -{}- lenp \\
		\tab \word{FIELD:} p.x		\tab[5.5] \word{bs} -{}- a-addr cell \\
		\tab \word{FIELD:} p.y      \tab[5.5] \word{bs} -{}- a-addr cell*2 \\
		\word{END-STRUCTURE} \\

		\word{BEGIN-STRUCTURE} rect  \tab[1.3]\word{bs} -{}- a-addr 0 ; -{}- lenr \\
		\tab point \word{+FIELD} r.tlhc   \tab \word{bs} -{}- a-addr cell*2 \\
		\tab point \word{+FIELD} r.brhc   \tab \word{bs} -{}- a-addr cell*4 \\
		\word{END-STRUCTURE}
		\end{quote}

	\item[Alignment]
		In practice, structures are used for two different purposes
		with incompatible requirements:
		\begin{enumerate}
		\item For collecting related internal-use data into a
			convenient ``package'' that can be referred to by a
			single ``handle''. For this use, alignment is important,
			so that efficient native fetch and store instructions
			can be used.

		\item For mapping external data structures like hardware
			register maps and protocol packets. For this use,
			automatic alignment is inappropriate, because the
			alignment of the external data structure often doesn't
			match the rules for a given processor.
		\end{enumerate}

		Many languages cater for the first use, but ignore the
		second.  This leads to various customized solutions, usage
		requirements, portability problems, bugs, etc.
		\word{+FIELD} is defined to be non-aligning, while the
		named field defining words (\emph{x}\texttt{FIELD:}) are
		aligning.  This is intentional and allows for both uses.

		The standard currently defines an aligned field defining
		word for each of the standard data types:

		\begin{center}
			\begin{tabular}{rl}
		\word{CFIELD:}				& a character \\
		\word{FIELD:}				& a native integer (single cell) \\
		\word[floating]{FFIELD:}	& a native float \\
		\word[floating]{SFFIELD:}	& a 32 bit float \\
		\word[floating]{DFFIELD:}	& a 64 bit float
			\end{tabular}
		\end{center}

		Although this is a sufficient set, most systems provide
		facilities to define field defining words for standard
		data types.
		% Note that these also satisfy the alignment requirements of
		% the host system, whereas \word{+FIELD} does not.

	\item[Future]
		The following cannot be defined until the required addressing
		has been defined. The names should be considered reserved
		until then.

		\begin{center}
			\begin{tabular}{rl}
			\texttt{BFIELD:} & 1 byte (8 bit) field \\
			\texttt{WFIELD:} & 16 bit field \\
			\texttt{LFIELD:} & 32 bit field \\
			\texttt{XFIELD:} & 64 bit field \\
			\end{tabular}
		\end{center}

	\implementation
		\defertext{Begin definition of a new structure. Use in the
		form \word{BEGIN-STRUCTURE} \arg{name}.  At run time
		\arg{name} returns the size of the structure.}

		\word{:} BEGIN-STRUCTURE\tab\word{bs} -{}- addr 0 ; -{}- size \\
		\tab \word{CREATE} \\
		\tab[2] \word{HERE} 0  0 \word{,} \tab[2] \word{bs}  mark stack, lay dummy \\
		\tab \word{DOES} \word{@} \tab[6]\word{bs} -{}- rec-len \\
		\word{;}
	\end{defer}
\end{worddef}


\begin{worddef}{}{CFIELD:}[c-field-colon][X:structures]
\item \stack{}{}

	The semantics of \word{CFIELD:} are identical to the
	execution semantics of the phrase:
	\begin{quote}\ttfamily
		1 \word{CHARS} \word{+FIELD}
	\end{quote}

\see \wref{facility:+FIELD}{+FIELD},
	\wref{facility:BEGIN-STRUCTURE}{BEGIN-STRUCTURE} and
	\wref{facility:END-STRUCTURE}{END-STRUCTURE}.

	\begin{defer}
	\implementation
		\defertext{Create a new field within a structure definition
		of size a character.}

		\word{:} cfield:\tab\word{bs} n1 <"name"> -{}- n2 ; Exec: addr -{}- 'addr \\
		\tab 1 \word{CHARS} \word{+FIELD} \\
		\word{;}
	\end{defer}
\end{worddef}

% -------------------------------------

\begin{worddef}{1305}{EKEY}[e-key]
\item \stack{}{u}

	Receive one keyboard event \param{u}. The encoding of keyboard events
	is implementation defined.

\see \wref{facility:KEYq}{KEY?},
	\wref{core:KEY}{KEY}.

	\begin{defer}
	\rationale % A.10.6.2.1305 EKEY
		\word{EKEY} provides a standard word to access a
		system-dependent set of ``raw'' keyboard events, including
		events corresponding to members of the standard character
		set, events corresponding to other members of the
		implementation-defined character set, and keystrokes that
		do not correspond to members of the character set.

		\word{EKEY} assumes no particular numerical correspondence
		between particular event code values and the values
		representing standard characters. On some systems, this may
		allow two separate keys that correspond to the same standard
		character to be distinguished from one another.
		A standard program may only interpret the results of
		\word{EKEY} via the translation words provided for that
		purpose (\word{EKEYtoCHAR} and \word{EKEYtoFKEY}).

		In systems that combine both keyboard and mouse events into
		a single ``event stream'', the single number returned by
		\word{EKEY} may be inadequate to represent the full range of
		input possibilities. In such systems, a single ``event
		record'' may include a time stamp, the x,y coordinates of
		the mouse position, the keyboard state, and the state of
		the mouse buttons. In such systems, it might be appropriate
		for \word{EKEY} to return the address of an ``event record''
		from which the other information could be extracted.

		While the standard specifies a timing relationship between
		\word{EKEYq}, \word{KEYq}, \word{EKEY} and \word{KEY}, some
		programmers find that confusing.
		One way to avoid such confusion is to use only one pairing
		in a program (for each input stream).  Use \word{KEYq} and
		\word{KEY} where the application does not require access to
		anything other than the standard character set.  Use
		\word{EKEYq} and \word{EKEY} when extended functionality is
		required.

		Also, consider a hypothetical Forth system running under
		MS-DOS on a PC-compatible computer. Assume that the
		implementation-defined character set is the ``normal'' 8-bit
		PC character set. In that character set, the codes from 0 to
		127 correspond to ASCII characters. The codes from 128 to 255
		represent characters from various non-English languages,
		mathematical symbols, and some graphical symbols used for line
		drawing. In addition to those characters, the keyboard can
		generate various other ``scan codes'', representing such
		non-character events as arrow keys and function keys.

		There may be multiple keys, with different scan codes,
		corresponding to the same standard character. For example,
		the character representing the number ``1'' often appears both
		in the row of number keys above the alphabetic keys, and also
		in the separate numeric keypad.

		When a program asks the MS-DOS operating system for a keyboard
		event, it receives either a single non-zero byte, representing
		a character, or a zero byte followed by a ``scan code'' byte,
		representing a non-character keyboard event (e.g., a function
		key).

		\word{EKEY} represents each keyboard event as a single number,
		rather than as a sequence of numbers. For the system described
		above, the following would be a reasonable implementation of
		\word{EKEY} and related words:

		\begin{quote}
			The \texttt{MAX-CHAR} environmental query would return 255.

			Assume the existence of a word
			\texttt{DOS-KEY} \stack{}{char}
			which executes the MS-DOS ``Direct STDIN Input'' system call
			(Interrupt 21h, Function 07h) and a word
			\texttt{DOS-KEY?} \stack{}{flag}
			which executes the MS-DOS ``Check STDIN Status'' system call
			(Interrupt 21h, Function 0Bh).

			\ttfamily
			\begin{tabbing}
			\tab \= \tab \= \tab \= \tab \= \hspace{7em} \= \kill
			\word{:} \word{EKEYq}~ \word{p} -{}- flag )~
				DOS-KEY?~ \word{0ne} \word{;} \\[\parskip]

			\word{:} \word{EKEY}~ \word{p} -{}- u )~
				DOS-KEY~ \word{qDUP} \word{0=} \word{IF}~
					DOS-KEY 256 \word{+}~ \word{THEN} \word{;} \\[\parskip]

			\+ \word{:} \word{EKEYtoCHAR} \word{p} u -{}- u false | char true ) \\
				\+ \word{DUP} 255 \word{more} \word{IF} 		\>\>\>\>	\word{p} u ) \\
					\word{DUP} 259 \word{=} \word{IF} 		\>\>\>		\word{bs} 259 is Ctrl-@ (ASCII NUL) \\
					\> \word{DROP} 0 \word{TRUE} \word{EXIT}\>\>		\word{bs} so replace with character \\
				\- \word{THEN} \word{FALSE} \word{EXIT}		\>\>\>		\word{bs} otherwise extended character \\
			\- \word{THEN} \word{TRUE}						\>\>\>\>	\word{bs} normal extended ASCII char. \\
			\word{;} \\[\parskip]

			\word{VARIABLE} PENDING-CHAR ~ -1 PENDING-CHAR \word{!} \\[\parskip]

			\+ \word{:} \word{KEYq}~ \word{p} -{}- flag ) \\
				\+ PENDING-CHAR \word{@} \word{0less} \word{IF} \\
					\+ \word{BEGIN}~ \word{EKEYq} \word{WHILE} \\
						\+ \word{EKEY} \word{EKEYtoCHAR} \word{IF} \\
						\-	PENDING-CHAR \word{!}~ \word{TRUE} \word{EXIT} \\
					\- \word{THEN} \word{DROP} \\
				\- \word{REPEAT}~ \word{FALSE} \word{EXIT} \\
			\- \word{THEN}~ \word{TRUE} \\
			\word{;} \\[\parskip]

			\+ \word{:} \word{KEY}~ \word{p} -{}- char ) \\
				\+ PENDING-CHAR \word{@} \word{0less} \word{IF} \\
					\word{BEGIN}~ \word{EKEY}~ \word{EKEYtoCHAR} \word{0=} \word{WHILE} \\
					\> \word{DROP} \\
				\-	\word{REPEAT}~ \word{EXIT} \\
			\- \word{THEN}~ PENDING-CHAR \word{@}~ -1 PENDING-CHAR \word{!} \\
			\word{;}
			\end{tabbing}
		\end{quote}

		This is a full-featured implementation, providing the
		application program with an easy way to either handle
		non-character events (with \word{EKEY}), or to ignore them
		and to only consider ``real'' characters (with
		\word{KEY}).

		Note that \word{EKEY} maps scan codes from 0 to 255 into
		numbers from 256 to 511. \word{EKEY} maps the number 259,
		representing the keyboard combination Ctrl-Shift-@, to the
		character whose numerical value is 0 (ASCII NUL). Many ASCII
		keyboards generate ASCII NUL for Ctrl-Shift-@, so we use that
		key combination for ASCII NUL (which is otherwise unavailable
		from MS-DOS, because the zero byte signifies that another
		scan-code byte follows).

		One consequence of using the ``Direct STDIN Input'' system call
		(function 7) instead of the ``STDIN Input'' system call
		(function 8) is that the normal DOS ``Ctrl-C interrupt'' behavior
		is disabled when the system is waiting for input (Ctrl-C would
		still cause an interrupt while characters are being output). On
		the other hand, if the ``STDIN Input'' system call (function 8)
		were used to implement \word{EKEY}, Ctrl-C interrupts would be
		enabled, but Ctrl-Shift-@ would also cause an interrupt, because
		the operating system would treat the second byte of the 0,3
		sequence as a Ctrl-C, even though the 3 is really a scan code
		and not a character. One ``best of both worlds'' solution is to
		use function 8 for the first byte received by \word{EKEY}, and
		function 7 for the scan code byte. For example:

		\begin{quote}
			\ttfamily
			\begin{tabbing}
			\tab \= \tab \= \tab \= \tab \= \hspace{7em} \= \kill
			\+ \word{:} \word{EKEY}~ \word{p} -{}- u ) \\
				\+ DOS-KEY-FUNCTION-8~ \word{qDUP}~ \word{0=}~ \word{IF} \\
					DOS-KEY-FUNCTION-7~ \word{DUP} 3~ \word{=}~ \word{IF} \\
					\> \word{DROP} 0~ \word{ELSE}~ 256 \word{+}\\
				\- \word{THEN} \\
			\- \word{THEN} \\
			\word{;}
			\end{tabbing}
		\end{quote}

		Of course, if the Forth implementor chooses to pass Ctrl-C
		through to the program, without using it for its usual
		interrupt function, then DOS function 7 is appropriate in both
		cases (and some additional care must be taken to prevent a
		typed-ahead Ctrl-C from interrupting the Forth system during
		output operations).

		A Forth system might also choose a simpler implementation of
		\word{KEY}, without implementing \word{EKEY}, as follows:

		\begin{quote}\ttfamily
			\word{:} \word{KEY}~~ \word{p} -{}- char )~
				DOS-KEY~
			\word{;}

			\word{:} \word{KEYq}~ \word{p} -{}- flag )~
				DOS-KEY?~ \word{0ne}~
			\word{;}
		\end{quote}

		The disadvantages of the simpler version are:

		\begin{enumerate}
		\item An application program that uses \word{KEY},
			expecting to receive only valid characters, might receive a
			sequence of bytes (e.g., a zero byte followed by a byte with
			the same numerical value as the letter ``A'' that appears to
			contain a valid character, even though the user pressed a key
			(e.g., function key 4) that does not correspond to any valid
			character.

		\item An application program that wishes to handle non-character
			events will have to execute \word{KEY} twice if it
			returns zero the first time. This might appear to be a
			reasonable and easy thing to do. However, such code is not
			portable to other systems that do not use a zero byte as an
			``escape'' code. Using the \word{EKEY} approach, the
			algorithm for handling keyboard events can be the same for
			all systems; the system dependencies can be reduced to a
			table or set of constants listing the system-dependent key
			codes used to access particular application functions.
			Without \word{EKEY}, the algorithm, not just the table, is
			likely to be system dependent.
		\end{enumerate}

		Another approach to \word{EKEY} on MS-DOS is to use the BIOS
		``Read Keyboard Status'' function (Interrupt 16h, Function 01h)
		or the related ``Check Keyboard'' function (Interrupt 16h,
		Function 11h). The advantage of this function is that it allows
		the program to distinguish between different keys that correspond
		to the same character (e.g. the two ``1'' keys). The disadvantage
		is that the BIOS keyboard functions read only the keyboard. They
		cannot be ``redirected'' to another ``standard input'' source,
		as can the DOS STDIN Input functions.
	\end{defer}
\end{worddef}


\begin{worddef}[EKEYtoCHAR]{1306}{EKEY>CHAR}[e-key-to-char]
\item \stack{u}{u false | char true}

	If the keyboard event \param{u} corresponds to a character in the
	implementation-defined character set, return that character and
	\emph{true}. Otherwise return \param{u} and \emph{false}.

	\begin{defer}
	\rationale % A.10.6.2.1306 EKEY>CHAR
		\word{EKEYtoCHAR} translates a keyboard event into the
		corresponding member of the character set, if such a
		correspondence exists for that event.

		It is possible that several different keyboard events may
		correspond to the same character, and other keyboard events
		may correspond to no character.
	\end{defer}
\end{worddef}


% -------------------------------------------------------------------


\begin{worddef}[EKEYtoFKEY]{}{EKEY>FKEY}[e-key-to-f-key][X:ekeys]
\item \stack{u_1}{u_2 f}

	If the keyboard event \param{u_1} corresponds to a keypress in the
	implementation-defined special key set, return that key's id
	\param{u_2} and \param{true}. Otherwise return \param{u_1} and
	\param{false}.

\note
	The keyboard may lack some of the keys, or the capability to report
	them. Programs should be written such that they also work (although
	less conveniently or with less functionality) if these key numbers
	cannot be produced.

\see \wref{facility:EKEY}{EKEY},
	\wref{facility:K-DELETE}{K-DELETE},
	\wref{facility:K-DOWN}{K-DOWN},
	\wref{facility:K-END}{K-END},
	\wref{facility:K-HOME}{K-HOME},
	\wref{facility:K-INSERT}{K-INSERT},
	\wref{facility:K-LEFT}{K-LEFT},
	\wref{facility:K-NEXT}{K-NEXT},
	\wref{facility:K-PRIOR}{K-PRIOR},
	\wref{facility:K-RIGHT}{K-RIGHT},
	\wref{facility:K-UP}{K-UP},
	\wref{facility:K-ALT-MASK}{K-ALT-MASK},
	\wref{facility:K-CTRL-MASK}{K-CTRL-MASK},
	\wref{facility:K-SHIFT-MASK}{K-SHIFT-MASK},
	\wref{facility:K-F1}{K-F1},
	\wref{facility:K-F2}{K-F2},
	\wref{facility:K-F3}{K-F3},
	\wref{facility:K-F4}{K-F4},
	\wref{facility:K-F5}{K-F5},
	\wref{facility:K-F6}{K-F6},
	\wref{facility:K-F7}{K-F7},
	\wref{facility:K-F8}{K-F8},
	\wref{facility:K-F9}{K-F9},
	\wref{facility:K-F10}{K-F10},
	\wref{facility:K-F11}{K-F11}, and
	\wref{facility:K-F12}{K-F12}.

	\begin{defer}
	\rationale
		This words has been provided to allow for systems which may not
		be able to interpret the value returned from \word{EKEY}
		directly. A simple implementation for a system which is capable
		of interpreting the value returned from \word{EKEY} would be:

		\begin{quote}
			\ttfamily
			\word{:} \word{EKEYtoFKEY} \word{p} u1 -{}- u2 flag ) \\
			\tab \word{DUP} \word{EKEYtoCHAR} \word{NIP} \word{0=} \word{;}
		\end{quote}

		The value returned from \word{EKEYtoFKEY} can be interpreted
		via a set of pre-defined constants and masks. This provides
		the application programmer with the ability to process the
		non-ASCII keys in a standard way. Note however, that not all
		keyboards provide these keys. Indeed, some devices will not
		have a keyboard. A standard program should be written in such
		a way that they will continue to work without these additional
		keys. Albeit with a limited or reduced functionality.

		The \texttt{K-}{\ldots} words produce the same values that the
		sequence \word{EKEY} \word{EKEYtoFKEY} may produce when the
		user presses the corresponding keys. Note that some systems
		may lack some of the keys, or the system the capability to
		report them. Programs should be written such that they continue
		to work (although less conveniently or with less functionality)
		if these key combinations cannot be produced.

		Typical Use:

		\begin{quote}
			{\ldots} \word{EKEY} \word{EKEYtoFKEY} \word{IF} \\
			\tab \word{CASE} \\
			\tab[2] \word{K-UP} \word{OF} {\ldots} \word{ENDOF} \\
			\tab[2] \word{K-F1} \word{OF} {\ldots} \word{ENDOF} \\
			\tab[2] \word{K-LEFT} \word{K-SHIFT-MASK} \word{OR}
			                      \word{K-CTRL-MASK} \word{OR}
			                    \word{OF} {\ldots} \word{ENDOF} \\
			\tab[2] {\ldots} \\
			\tab \word{ENDCASE} \\
			\word{ELSE} \\
			\tab {\ldots} \\
			\word{THEN}
		\end{quote}

	\item[\word{EKEY} return values] ~\\
		The intention behind \word{EKEY} was that it would return the
		implementation defined keyboard scan code. The implementation
		defined nature of the value means that a standard program may
		not use the value in any way, other than passing it on to
		\word{EKEYtoCHAR} to convert it into an ASCII character.

		\word{EKEYtoFKEY} has been designed to be used in a similar
		manner. It provides an implementation defined value which
		corresponds to non-ASCII keys, or a combination thereof. A
		standard program may check which key combination has been used
		via a set of pre-defined constants.

%		There was a discussion about what the standard says about
%		EKEY return values. In particular, the non-specification
%		of a lifetime for the return value has been interpreted as
%		meaning that it has unlimited lifetime and thus an
%		implementation where the return value is an address of an
%		overwritable buffer is non-standard; whereas others believes
%		that the implementation-defined nature of the result would make
%		such an EKEY implementation standard. However, no such
%		implementation of EKEY is known, and a clarification of
%		that aspect is desirable. However, with the introduction of
%		EKEY>FKEY the proposal could even be implemented on a
%		system with such an EKEY implementation, so the place
%		for the clarification is probably not in this proposal
%		(unless we take EKEY>FKEY out again).

%		Programming advice

	\item[Shift keys] ~\\
		Note that, as defined, the shift key masks
		(\wref{facility:K-SHIFT-MASK}{K-SHIFT-MASK},
		 \wref{facility:K-CTRL-MASK}{K-CTRL-MASK} and
		 \wref{facility:K-ALT-MASK}{K-ALT-MASK})
		are only useful for recognising shifted cursor and function
		keys, because these are the only values defined for use with
		\word{EKEYtoFKEY}.
		E.g., a standard program cannot recognise \textsc{Alt-T},
		because no \word{EKEY} return value for \texttt{T} has been
		defined.

	\implementation*
		The implementation is closely tied to the implementation of
		\word{EKEY} and therefore unportable.

	\testing
		\{ \word{K-LEFT}  \word{TRUE} -> \word{CR} \word{.q} Please press <left>"  \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-RIGHT} \word{TRUE} -> \word{CR} \word{.q} Please press <right>" \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-UP}    \word{TRUE} -> \word{CR} \word{.q} Please press <up>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-DOWN}  \word{TRUE} -> \word{CR} \word{.q} Please press <down>"  \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-HOME}  \word{TRUE} -> \word{CR} \word{.q} Please press <home>"  \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-END}   \word{TRUE} -> \word{CR} \word{.q} Please press <end>"   \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-PRIOR} \word{TRUE} -> \word{CR} \word{.q} Please press <prior>" \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-NEXT}  \word{TRUE} -> \word{CR} \word{.q} Please press <next>"  \word{EKEY} \word{EKEYtoFKEY} \} \\

		\{ \word{K-F1}    \word{TRUE} -> \word{CR} \word{.q} Please press <F1>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F2}    \word{TRUE} -> \word{CR} \word{.q} Please press <F2>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F3}    \word{TRUE} -> \word{CR} \word{.q} Please press <F3>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F4}    \word{TRUE} -> \word{CR} \word{.q} Please press <F4>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F5}    \word{TRUE} -> \word{CR} \word{.q} Please press <F5>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F6}    \word{TRUE} -> \word{CR} \word{.q} Please press <F6>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F7}    \word{TRUE} -> \word{CR} \word{.q} Please press <F7>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F8}    \word{TRUE} -> \word{CR} \word{.q} Please press <F8>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F9}    \word{TRUE} -> \word{CR} \word{.q} Please press <F9>"    \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F10}   \word{TRUE} -> \word{CR} \word{.q} Please press <F10>"   \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F11}   \word{TRUE} -> \word{CR} \word{.q} Please press <F11>"   \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-F12}   \word{TRUE} -> \word{CR} \word{.q} Please press <F12>"   \word{EKEY} \word{EKEYtoFKEY} \} \\

		\{ \word{K-LEFT} \word{K-SHIFT-MASK} \word{OR} \word{TRUE} -> \\
		\tab \word{CR} \word{.q} Please press <shift-left>" \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-LEFT} \word{K-CTRL-MASK}  \word{OR} \word{TRUE} -> \\
		\tab \word{CR} \word{.q} Please press <ctrl-left>"  \word{EKEY} \word{EKEYtoFKEY} \} \\
		\{ \word{K-LEFT} \word{K-ALT-MASK}   \word{OR} \word{TRUE} -> \\
		\tab \word{CR} \word{.q} Please press <alt-left>"   \word{EKEY} \word{EKEYtoFKEY} \} \\

		\{ \word{CR} \word{.q} Please press <a>" \word{EKEY} \word{EKEYtoFKEY} \word{NIP} \word{SWAP} \word{EKEYtoCHAR} \\
		\tab -> \word{FALSE} \word{CHAR} a \word{TRUE} \}
	\end{defer}
\end{worddef}


% -------------------------------------------------------------------

\begin{worddef}[EKEYq]{1307}{EKEY?}[e-key-question]
\item \stack{}{flag}

	If a keyboard event is available, return \emph{true}. Otherwise
	return \emph{false}. The event shall be returned by the next
	execution of \word{EKEY}.

	After \word{EKEYq} returns with a value of \emph{true},
	subsequent executions of \word{EKEYq} prior to the execution of
	\word[core]{KEY}, \word{KEYq} or \word{EKEY} also return
	\emph{true}, referring to the same event.
\end{worddef}


\begin{worddef}[EMITq]{1325}{EMIT?}[emit-question]
\item \stack{}{flag}

	\param{flag} is true if the user output device is ready to
	accept data and the execution of \word[core]{EMIT} in place of
	\word{EMITq} would not have suffered an indefinite delay. If
	the device status is indeterminate, \emph{flag} is true.

	\begin{defer}
	\rationale % A.10.6.2.1325 EMIT?
		An indefinite delay is a device related condition, such as
		printer off-line, that requires operator intervention before
		the device will accept new data.
	\end{defer}
\end{worddef}

% -------------------------------------

\begin{worddef}{}{END-STRUCTURE}[][X:structures]
\item \stack{struct-sys +n}{}

	Terminate definition of a structure started by
	\word{BEGIN-STRUCTURE}.

\see \wref{facility:+FIELD}{+FIELD} and
	\wref{facility:BEGIN-STRUCTURE}{BEGIN-STRUCTURE}.

	\begin{defer}
	\implementation
		\defertext{Terminate definition of a structure.}

		\word{:} END-STRUCTURE\tab\word{bs} addr n -{}- \\
		\tab \word{SWAP} \word{!} \word{;} \tab[4.2]\word{bs} set len
	\end{defer}
\end{worddef}


\begin{worddef}{}{FIELD:}[field-colon][X:structures]
\item \stack{}{}

	The semantics of \word{FIELD:} are identical to the
	execution semantics of the phrase:
	\begin{quote}\ttfamily
		\word{ALIGNED} 1 \word{CELLS} \word{+FIELD}
	\end{quote}

\see \wref{facility:+FIELD}{+FIELD},
	\wref{facility:BEGIN-STRUCTURE}{BEGIN-STRUCTURE} and
	\wref{facility:END-STRUCTURE}{END-STRUCTURE}.

	\begin{defer}
	\implementation
		\defertext{Create a new field within a structure definition
		of size a cell. The field is aligned.}

		\word{:} field:\tab\word{bs} n1 <"name"> -{}- n2 ; Exec: addr -{}- 'addr \\
		\tab \word{ALIGNED} 1 \word{CELLS} \word{+FIELD} \\
		\word{;}
	\end{defer}

\end{worddef}

% -------------------------------------------------------------------

\begin{worddef}{}{K-ALT-MASK}[][X:ekeys]
\item \stack{}{u}

	Mask for the \textsc{Alt} key, that can be \word{OR}ed with the
	key value to produce a value that the sequence \word{EKEY}
	\word{EKEYtoFKEY} may produce when the user presses the
	corresponding key combination.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-CTRL-MASK}[][X:ekeys]
\item \stack{}{u}

	Mask for the \textsc{Ctrl} key, that can be \word{OR}ed with the
	key value to produce a value that the sequence \word{EKEY}
	\word{EKEYtoFKEY} may produce when the user presses the
	corresponding key combination.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-DELETE}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``Delete'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-DOWN}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``cursor down'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-END}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``End'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F1}[k-f-1][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F1'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F10}[k-f-10][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F10'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F11}[k-f-11][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F11'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F12}[k-f-12][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F12'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F2}[k-f-2][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F2'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F3}[k-f-3][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F3'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F4}[k-f-4][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F4'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F5}[k-f-5][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F5'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F6}[k-f-6][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F6'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F7}[k-f-7][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F7'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F8}[k-f-8][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F8'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-F9}[k-f-9][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``F9'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-HOME}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``home'' or ``Pos1'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-INSERT}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``Insert'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-LEFT}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``cursor left'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-NEXT}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``PgDn'' (Page Down) or ``Next'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-PRIOR}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``PgUp'' (Page Up) or ``Prior'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-RIGHT}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``cursor right'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-SHIFT-MASK}[][X:ekeys]
\item \stack{}{u}

	Mask for the \textsc{Shift} key, that can be \word{OR}ed with the
	key value to produce a value that the sequence \word{EKEY}
	\word{EKEYtoFKEY} may produce when the user presses the
	corresponding key combination.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


\begin{worddef}{}{K-UP}[][X:ekeys]
\item \stack{}{u}

	Leaves the value \param{u} that the sequence \word{EKEY}
	\word{EKEYtoFKEY} would produce when the user presses the
	``cursor up'' key.

\see \wref{facility:EKEYtoFKEY}{EKEY>FKEY},
	\rref{facility:EKEYtoFKEY}{EKEY>FKEY}.
\end{worddef}


% -------------------------------------------------------------------


\begin{worddef}{1905}{MS}
\item \stack{u}{}

	Wait at least \param{u} milliseconds.

\note
	The actual length and variability of the time period depends
	upon the implementation-defined resolution of the system clock
	and upon other system and computer characteristics beyond the
	scope of this Standard.

	\begin{defer}
	\rationale % A.10.6.2.1905 MS
		Although their frequencies vary, every system has a clock.
		Since many programs need to time intervals, this word is
		offered. Use of milliseconds as an internal unit of time is
		a practical ``least common denominator'' external unit. It
		is assumed implementors will use ``clock ticks'' (whatever
		size they are) as an internal unit and convert as appropriate.
	\end{defer}
\end{worddef}


\begin{worddef}[TIMEandDATE]{2292}{TIME\&DATE}[time-and-date]
\item \stack{}{+n_1 +n_2 +n_3 +n_4 +n_5 +n_6}

	Return the current time and date.
	\param{+n_1} is the second \{0{\ldots}59\},
	\param{+n_2} is the minute \{0{\ldots}59\},
	\param{+n_3} is the hour \{0{\ldots}23\},
	\param{+n_4} is the day \{1{\ldots}31\},
	\param{+n_5} is the month \{1{\ldots}12\}, and
	\param{+n_6} is the year (e.g., 1991).

	\begin{defer}
	\rationale % A.10.6.2.2292 TIME&DATE
		Most systems have a real-time clock/calendar.
		This word gives portable access to it.
	\end{defer}
\end{worddef}
